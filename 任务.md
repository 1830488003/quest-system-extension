// ==UserScript==
// @name         SillyTavern - Quest System (Entry in Extensions Menu)
// @namespace    http://tampermonkey.net/
// @version      0.4.11
// @description  Moves Quest Log entry point into the SillyTavern Extensions menu. AI judges completion; injects context; segmented editable Chinese prompt core; no preloaded tasks.
// @author       萧然 & Gemini
// @match        */*
// @grant        none
// ==/UserScript==

(() => {
    "use strict";

    console.log('[QuestSystem v0.4.11] Script loading...');

    // --- Configuration ---
    const DEBUG_MODE = true;
    // ID for the quest log item within the extensions menu
    const QUEST_MENU_ITEM_ID = 'st-quest-system-extensions-menu-entry';
    const QUEST_MENU_ITEM_CONTAINER_ID = 'st-quest-system-extensions-menu-container';

    const QUEST_POPUP_ID = 'th-quest-system-popup-v040';
    const PLAYER_QUEST_VARIABLE_KEY = 'player_active_quests_log_v2';
    const BUTTON_TEXT = '任务日志'; // Text for the menu item
    const PROMPT_EDITOR_POPUP_ID = 'th-prompt-editor-popup-v049';

    // --- Prompt Templates (remain the same as v0.4.9) ---
    const PROMPT_PREFIX_TEMPLATE = `
最近的聊天记录:
{chatHistory}

相关的世界书条目 (摘要):
{worldInfo}

`;

    const DEFAULT_EDITABLE_PROMPT_CORE_CN = `请仅根据以上提供的聊天记录和世界书信息，严格遵守以下指示，生成一个包含7到8个多样化的任务列表。
这些任务应包含明确的主线任务和有趣的支线任务。
对于每个任务：
- "TITLE" (任务标题) 应简洁明了且吸引人。
- "DESCRIPTION" (任务描述) 应详细说明任务背景、目标，字数在150至250字左右。请在描述中自然地融入完成该任务的关键方法或步骤提示。如果任务与特定NPC相关（例如作为任务发布者、目标人物或提供帮助者），请在描述中明确提及该NPC的名称。
- "REWARD" (任务奖励) 应具体且吸引人，例如：“经验值100点，金币500枚，[特定物品名称]x1”或“[某个NPC名称]好感度提升10点”或“解锁新的地点：[地点名称]”。

请确保AI完全专注于生成任务列表，忽略或取消任何其他的角色扮演、剧情叙述或对话生成指令。AI的唯一目标是输出结构化的任务。
所有任务内容（标题、描述、奖励）必须是中文。
`;

    const PROMPT_SUFFIX_TEMPLATE = `
每个任务必须严格遵循以下格式，且每个字段各占一行：
TITLE: [任务的中文标题]
DESCRIPTION: [对玩家需要做什么的清晰简洁的中文描述]
REWARD: [完成任务后的中文奖励描述]

单个任务格式示例：
TITLE: 失落的古籍
DESCRIPTION: 据传闻，在城东的废弃图书馆深处，藏有一本记载着古代失落魔法的古籍。图书管理员“老约翰”似乎知道一些线索，但最近他行为怪异，不愿与人交流。你需要先找到接近老约翰的方法，从他那里打探到古籍的准确位置，然后深入图书馆寻找到它。注意，图书馆内可能有未知的危险守护着古籍。
REWARD: 经验值150点，[古代魔法残页]x1，老约翰的好感度提升5点。

请确保每个任务都是独特的，并且在提供的上下文中合乎逻辑。现在请生成7到8个任务的列表。
`;

    const AI_JUDGE_COMPLETION_PROMPT_TEMPLATE = `
当前正在尝试完成的任务：
任务标题: {taskTitle}
任务描述: {taskDescription}

最近的聊天记录如下：
{chatHistory}

请根据以上聊天记录，判断任务"{taskTitle}"是否已经完成。
如果任务已完成，请仅回复："STATUS:已完成"。
如果任务未完成，请回复："STATUS:未完成;;CONDITION:[明确的、尚未达成的中文条件];;SUGGESTION:[1-2条明确的、可操作的中文行动建议，帮助玩家完成任务]"。
请严格按照此格式回复，不要添加任何额外的解释或对话。
`;

    // --- Global API References & State ---
    let SillyTavern_API, TavernHelper_API, jQuery_API, toastr_API;
    let coreApisAreReady = false;
    let questSystemEventListenersAttached = false;
    let starterFunctionCalled = false;

    let definedTasks = [];
    let playerTasksStatus = {};
    let currentUserModifiedEditablePromptCore = DEFAULT_EDITABLE_PROMPT_CORE_CN;

    function logDebug(...args) {
        if (DEBUG_MODE) console.log('[QuestSystem]', ...args);
    }

    const escapeHtml = (unsafe) => {
        if (unsafe === null || typeof unsafe === 'undefined') return '';
        return String(unsafe)
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    };

    function attemptToLoadCoreApis() {
        // ... (same as v0.4.10)
        logDebug("Attempting to load core APIs (v0.4.11)...");
        const parentWin = typeof window.parent !== "undefined" ? window.parent : window;

        SillyTavern_API = (typeof SillyTavern !== 'undefined') ? SillyTavern : parentWin.SillyTavern;
        TavernHelper_API = (typeof TavernHelper !== 'undefined') ? TavernHelper : parentWin.TavernHelper;
        jQuery_API = parentWin.jQuery || parentWin.$ || (typeof $ !== 'undefined' ? $ : null);
        toastr_API = parentWin.toastr || (typeof toastr !== 'undefined' ? toastr : null);

        let allGood = true;
        if (!jQuery_API) { logDebug("jQuery (jQuery_API) is MISSING."); allGood = false; }

        if (!SillyTavern_API) { logDebug("SillyTavern API (SillyTavern_API) is MISSING."); allGood = false; }
        else if (typeof SillyTavern_API.callGenericPopup !== 'function' || typeof SillyTavern_API.POPUP_TYPE === 'undefined' || typeof SillyTavern_API.addOneMessage !== 'function') {
            logDebug("SillyTavern_API crucial functions (callGenericPopup, POPUP_TYPE, addOneMessage) are MISSING."); allGood = false;
        }

        if (!TavernHelper_API) { logDebug("TavernHelper API (TavernHelper_API) is MISSING."); allGood = false; }
        else if (typeof TavernHelper_API.getVariables !== 'function' ||
                   typeof TavernHelper_API.insertOrAssignVariables !== 'function' ||
                   typeof TavernHelper_API.generateRaw !== 'function' ||
                   typeof TavernHelper_API.getChatMessages !== 'function' ||
                   typeof TavernHelper_API.getCurrentCharPrimaryLorebook !== 'function' ||
                   typeof TavernHelper_API.getLorebookEntries !== 'function' ||
                   typeof TavernHelper_API.getLastMessageId !== 'function' ||
                   typeof TavernHelper_API.createChatMessages !== 'function' ) {
            logDebug("One or more critical TavernHelper_API functions (including generateRaw, createChatMessages) for QuestSystem are MISSING."); allGood = false;
        }

        coreApisAreReady = allGood;
        if (allGood) logDebug("Core APIs successfully loaded/verified.");
        else logDebug("Failed to load one or more critical APIs.");
        return allGood;
    }

    async function injectSystemMessage(messageContent) {
        // ... (same as v0.4.10)
         if (!coreApisAreReady || !TavernHelper_API || typeof TavernHelper_API.createChatMessages !== 'function') {
            toastr_API?.error("无法注入系统消息：核心API (TavernHelper.createChatMessages) 未就绪。");
            console.error("[QuestSystem] injectSystemMessage failed: TavernHelper.createChatMessages not available.");
            return;
        }
        try {
            await TavernHelper_API.createChatMessages([{
                role: 'system',
                name: '任务系统',
                message: messageContent,
                is_hidden: false
            }], { refresh: 'affected' });
            logDebug("System message injected into chat:", messageContent);
        } catch (error) {
            console.error('[QuestSystem] Error injecting system message:', error);
            toastr_API?.error(`注入系统消息失败: ${error.message}`);
        }
    }

    // Functions: loadPlayerTasks, savePlayerTasks, acceptTask, abandonTask, completeTask, generateAndAddNewAiTask, showPromptEditorPopup
    // These functions remain largely the same as in v0.4.9 / v0.4.10 in terms of their internal logic for task management and AI interaction.
    // The primary change is how the main "Quest" button/entry point is created and where it's located.
    // For brevity, I will not repeat all of them here, but assume they are present and correct from v0.4.9.
    // I will focus on the modified setupQuestButton (now setupQuestMenuItem) and related UI functions.

    async function loadPlayerTasks() { /* ... Same as v0.4.10 ... */ 
        logDebug("Loading player tasks...");
        if (!coreApisAreReady) { toastr_API?.error("核心服务未就绪 (LPT)。"); playerTasksStatus = {}; return; }
        try {
            const variables = await TavernHelper_API.getVariables({ type: 'chat' });
            playerTasksStatus = (variables && variables[PLAYER_QUEST_VARIABLE_KEY]) ? JSON.parse(JSON.stringify(variables[PLAYER_QUEST_VARIABLE_KEY])) : {};
            logDebug("Player tasks loaded:", playerTasksStatus);
        } catch (error) { console.error('[QuestSystem] Error loading tasks:', error); toastr_API?.error(`加载任务数据出错: ${error.message}`); playerTasksStatus = {}; }
    }

    async function savePlayerTasks() { /* ... Same as v0.4.10 ... */ 
        logDebug("Saving player tasks...", playerTasksStatus);
        if (!coreApisAreReady) { toastr_API?.error("核心服务未就绪 (SPT)。"); return; }
        try {
            await TavernHelper_API.insertOrAssignVariables({ [PLAYER_QUEST_VARIABLE_KEY]: playerTasksStatus }, { type: 'chat' });
            logDebug("Player tasks saved.");
            if (jQuery_API) {
                const popupContent = jQuery_API(`dialog[open]:not([closing]) #${QUEST_POPUP_ID}`);
                if (popupContent.length > 0) {
                    popupContent.html(createQuestPopupHtml());
                    bindQuestPopupEvents(popupContent);
                }
            }
        } catch (error) { console.error('[QuestSystem] Error saving tasks:', error); toastr_API?.error(`保存任务数据出错: ${error.message}`); }
    }

    async function acceptTask(taskId) { /* ... Same as v0.4.10 ... */ 
        if (!coreApisAreReady) { toastr_API?.error("核心服务未就绪 (AT)。"); return; }
        const taskDef = definedTasks.find(t => t.id === taskId);
        if (!taskDef) { toastr_API?.error(`任务 ${taskId} 未定义！`); return; }
        logDebug(`Accepting task: ${taskId}`);
        playerTasksStatus[taskId] = {
            status: 'active',
            startTime: Date.now(),
            title: taskDef.title,
            description: taskDef.description,
            rewardMessage: taskDef.rewardMessage,
            isAIGenerated: taskDef.isAIGenerated || false
        };
        await savePlayerTasks(); 
        toastr_API?.success(`已接受任务: ${taskDef.title}`);
        const acceptanceMessage = `${SillyTavern_API.name1 || '玩家'} 已接受任务: "${taskDef.title}"。\n任务描述: ${taskDef.description}`;
        await injectSystemMessage(acceptanceMessage);
    }
    
    async function abandonTask(taskId) { /* ... Same as v0.4.10 ... */ 
        logDebug(`Attempting to abandon task: ${taskId}`);
        if (!coreApisAreReady) { toastr_API?.error("核心服务未就绪 (ABT)。"); return; }

        const taskInPlayerLog = playerTasksStatus[taskId];

        if (!taskInPlayerLog || taskInPlayerLog.status !== 'active') {
            const taskTitle = taskInPlayerLog?.title || definedTasks.find(t => t.id === taskId)?.title || taskId;
            toastr_API?.warning(`任务 "${taskTitle}" 并非激活状态，无法放弃。`);
            logDebug(`Abandon task failed: Task ${taskId} not active in player log.`);
            return;
        }

        logDebug(`Abandoning task: ${taskInPlayerLog.title} (ID: ${taskId})`);

        const isAIGenerated = taskInPlayerLog.isAIGenerated;
        const abandonedTaskTitle = taskInPlayerLog.title; 

        delete playerTasksStatus[taskId]; 

        if (isAIGenerated) {
            definedTasks = definedTasks.filter(dt => dt.id !== taskId);
            logDebug(`AI Task ${taskId} ("${abandonedTaskTitle}") removed from definedTasks.`);
        }
        
        await injectSystemMessage(`${SillyTavern_API.name1 || '玩家'} 已放弃任务: "${abandonedTaskTitle}".`);
        await savePlayerTasks(); 
        toastr_API?.info(`任务已放弃: ${abandonedTaskTitle}`);
    }

    async function completeTask(taskId) { /* ... Same as v0.4.10 ... */ 
        logDebug(`Attempting to complete task: ${taskId}`);
        if (!coreApisAreReady) { toastr_API?.error("核心服务未就绪 (CT)。"); return; }

        const taskDataFromStatus = playerTasksStatus[taskId];
        const taskDef = taskDataFromStatus || definedTasks.find(t => t.id === taskId);

        if (!taskDataFromStatus || taskDataFromStatus.status !== 'active') {
            const taskTitleForWarning = taskDataFromStatus?.title || taskDef?.title || taskId;
            toastr_API?.warning(`任务 "${taskTitleForWarning}" 状态异常或非激活，无法处理完成。`);
            logDebug("Task completion attempt failed: Task not active or not found in player status.", taskDef, taskDataFromStatus);
            return;
        }
        
        const currentTaskTitle = taskDataFromStatus.title;
        const currentTaskDescription = taskDataFromStatus.description;

        const genButton = jQuery_API(`#current-tasks-list .quest-item[data-task-id="${taskId}"] .complete`);
        const originalButtonHtml = genButton.length ? genButton.html() : '完成任务';
        if(genButton.length) genButton.prop('disabled', true).html('<i class="fas fa-spinner fa-spin"></i> AI判断中...');

        try {
            let chatHistoryString = "无最近聊天记录。";
            const lastMessageId = TavernHelper_API.getLastMessageId();
            let messageRange = "0"; 
            if (typeof lastMessageId === 'number' && lastMessageId > 0) {
                const startMessageId = Math.max(0, lastMessageId - 9); 
                messageRange = `${startMessageId}-${lastMessageId}`;
            } else if (typeof lastMessageId === 'number' && lastMessageId === 0) {
                messageRange = "0-0";
            }
            logDebug(`Calculated message range for AI judgment: ${messageRange}`);
            const messages = await TavernHelper_API.getChatMessages(messageRange, { include_swipes: false }); 
            if (messages && messages.length > 0) {
                chatHistoryString = messages.map(m => `${escapeHtml(m.name)}: ${escapeHtml(m.message)}`).join('\n');
            }

            const judgePromptUserContent = AI_JUDGE_COMPLETION_PROMPT_TEMPLATE
                .replace(/{taskTitle}/g, escapeHtml(currentTaskTitle)) 
                .replace('{taskDescription}', escapeHtml(currentTaskDescription))
                .replace('{chatHistory}', chatHistoryString);

            const ordered_prompts = [
                { role: 'system', content: "你是一个辅助判断任务是否完成的AI。请根据用户提供的任务信息和聊天记录进行分析，并严格按照指定格式回复。" },
                { role: 'user', content: judgePromptUserContent }
            ];

            logDebug("Sending task completion judgment request to AI:", JSON.stringify(ordered_prompts, null, 2));
            const aiResponse = await TavernHelper_API.generateRaw({ ordered_prompts: ordered_prompts, max_new_tokens: 250 }); 
            logDebug("AI judgment response:", aiResponse);

            const cleanedResponse = aiResponse.trim();
            if (cleanedResponse.startsWith("STATUS:已完成")) {
                playerTasksStatus[taskId].status = 'completed';
                playerTasksStatus[taskId].endTime = Date.now();
                
                const finalRewardMessage = playerTasksStatus[taskId].rewardMessage || "无特定奖励信息";

                toastr_API?.success(`任务完成: ${currentTaskTitle}`);
                const completionMessage = `${SillyTavern_API.name1 || '玩家'} 已完成任务: "${currentTaskTitle}"！获得奖励: ${finalRewardMessage}`;
                await injectSystemMessage(completionMessage);
                await savePlayerTasks(); 

            } else if (cleanedResponse.startsWith("STATUS:未完成")) {
                let condition = "未知";
                let suggestion = "请根据任务描述继续努力。";
                const conditionMatch = cleanedResponse.match(/CONDITION:\[(.*?)]/);
                const suggestionMatch = cleanedResponse.match(/SUGGESTION:\[(.*?)]/);
                if (conditionMatch && conditionMatch[1]) condition = conditionMatch[1];
                if (suggestionMatch && suggestionMatch[1]) suggestion = suggestionMatch[1];

                const notCompletedMessage = `任务 "${currentTaskTitle}" 尚未完成。\n你需要: ${condition}\n或许可以尝试: ${suggestion}`;
                await injectSystemMessage(notCompletedMessage);
                toastr_API?.info(`任务 "${currentTaskTitle}" 尚未完成。AI建议已注入聊天。`);
            } else {
                await injectSystemMessage(`AI未能明确判断任务 "${currentTaskTitle}" 的完成状态。请您自行确认或稍后再试。AI原始回复：${cleanedResponse}`);
                toastr_API?.warning(`AI判断任务 "${currentTaskTitle}" 完成状态失败。`);
            }

        } catch (error) {
            console.error(`[QuestSystem] Error during AI task completion judgment for task ${taskId}:`, error);
            toastr_API?.error(`AI判断任务完成时出错: ${error.message}`);
            await injectSystemMessage(`尝试由AI判断任务 "${currentTaskTitle}" 的完成状态时发生错误。`);
        } finally {
            const currentGenButtonInstance = jQuery_API(`#current-tasks-list .quest-item[data-task-id="${taskId}"] .complete`);
            if(currentGenButtonInstance.length) {
                currentGenButtonInstance.prop('disabled', false).html(originalButtonHtml);
            } else {
                logDebug("Completion button for task", taskId, "not found after AI judgment (likely due to UI refresh).");
            }
        }
    }

    async function generateAndAddNewAiTask() { /* ... Same as v0.4.10 ... */ 
        logDebug("Attempting to generate AI task using generateRaw and current prompt template parts...");
        if (!coreApisAreReady) {
            toastr_API?.error("核心服务未就绪 (AI Task Gen)。");
            return;
        }
        const genButton = jQuery_API('#trigger-ai-task-generation');
        const originalButtonHtml = genButton.length ? genButton.html() : '<i class="fas fa-magic"></i> 生成AI任务';
        if(genButton.length) genButton.prop('disabled', true).html('<i class="fas fa-spinner fa-spin"></i> AI思考中...');

        try {
            let chatHistoryString = "无最近聊天记录。";
            let worldInfoString = "未加载相关的世界设定信息。";

            const lastMessageId = TavernHelper_API.getLastMessageId();
            let messageRange = "0";
            if (typeof lastMessageId === 'number' && lastMessageId > 0) {
                const startMessageId = Math.max(0, lastMessageId - 4);
                messageRange = `${startMessageId}-${lastMessageId}`;
            } else if (typeof lastMessageId === 'number' && lastMessageId === 0) {
                 messageRange = "0-0";
            }
            logDebug(`Calculated message range for AI: ${messageRange}`);

            const messages = await TavernHelper_API.getChatMessages(messageRange, { include_swipes: false });
            if (messages && messages.length > 0) {
                chatHistoryString = messages.map(m => `${escapeHtml(m.name)}: ${escapeHtml(m.message)}`).join('\n');
            }
            logDebug("Chat History for AI:\n", chatHistoryString);

            const primaryLorebookName = await TavernHelper_API.getCurrentCharPrimaryLorebook();
            if (primaryLorebookName) {
                const lorebookEntries = await TavernHelper_API.getLorebookEntries(primaryLorebookName);
                if (lorebookEntries && lorebookEntries.length > 0) {
                    worldInfoString = lorebookEntries
                        .filter(entry => entry.enabled && entry.content && entry.content.trim() !== '')
                        .slice(0, 5)
                        .map(entry => `条目名称: ${escapeHtml(entry.comment)}\n条目内容: ${escapeHtml(entry.content)}`)
                        .join('\n\n');
                }
            }
            logDebug("World Info for AI:\n", worldInfoString);

            const finalUserPrompt = PROMPT_PREFIX_TEMPLATE.replace('{chatHistory}', chatHistoryString).replace('{worldInfo}', worldInfoString)
                                  + currentUserModifiedEditablePromptCore
                                  + PROMPT_SUFFIX_TEMPLATE;

            const ordered_prompts = [
                {
                    role: 'system',
                    content: "你是一个AI任务生成系统。你的唯一任务是根据用户提供的上下文和核心指令生成一个结构化的任务列表。严格遵循用户要求的输出格式，不要进行任何角色扮演或剧情叙述。"
                },
                {
                    role: 'user',
                    content: finalUserPrompt
                }
            ];

            logDebug("Final AI Prompt (for generateRaw) being sent:\n", JSON.stringify(ordered_prompts, null, 2));

            let generatedText = await TavernHelper_API.generateRaw({
                ordered_prompts: ordered_prompts,
                max_new_tokens: 2048 
            });

            if (!generatedText || generatedText.trim() === "") {
                toastr_API?.error("AI未能返回任务文本。");
                if(genButton.length) genButton.prop('disabled', false).html(originalButtonHtml);
                return;
            }
            const cleanedText = generatedText.trim();
            logDebug("AI Raw Generated Text (Cleaned):\n", cleanedText);

            const questBlocksRegex = /^\s*TITLE:\s*(.*?)\s*DESCRIPTION:\s*(.*?)\s*REWARD:\s*(.*?)(?=\n\s*TITLE:|$)/gims;
            let match;
            let tasksGeneratedCount = 0;
            const tempNewTasks = [];

            while ((match = questBlocksRegex.exec(cleanedText)) !== null) {
                const parsedTitle = match[1] ? match[1].trim() : null;
                const parsedDescription = match[2] ? match[2].trim() : null;
                const parsedReward = match[3] ? match[3].trim() : null;

                if (parsedTitle && parsedDescription && parsedReward) {
                    const newTask = {
                        id: 'ai_task_' + Date.now() + '_' + Math.random().toString(36).substring(2, 7) + '_' + tasksGeneratedCount,
                        title: parsedTitle,
                        description: parsedDescription,
                        status: 'available',
                        prerequisites: [],
                        rewardMessage: parsedReward,
                        isAIGenerated: true
                    };
                    tempNewTasks.push(newTask);
                    tasksGeneratedCount++;
                    logDebug("Successfully parsed AI Task:", newTask);
                } else {
                    logDebug("Partial match, skipping a block. Title:", parsedTitle, "Desc:", parsedDescription, "Reward:", parsedReward);
                }
            }

            if (tasksGeneratedCount === 0) {
                 toastr_API?.error("AI返回的任务格式不正确，无法解析出任何有效任务。请检查控制台中的原始AI回复。");
                 logDebug("Failed to parse any quests from AI response. Raw (Cleaned):", cleanedText);
                 if(genButton.length) genButton.prop('disabled', false).html(originalButtonHtml);
                 return;
            }

            tempNewTasks.forEach(newTask => {
                if (!definedTasks.some(task => task.title === newTask.title && task.isAIGenerated)) {
                    definedTasks.push(newTask);
                } else {
                    logDebug(`AI-generated task "${newTask.title}" already exists or is very similar. Skipping.`);
                }
            });

            toastr_API?.success(`AI成功生成了 ${tasksGeneratedCount} 个新任务!`, "任务系统");
            await savePlayerTasks();

        } catch (error) {
            console.error('[QuestSystem] Error generating AI task:', error);
            toastr_API?.error(`AI任务生成失败: ${error.message}`);
        } finally {
            if(genButton.length) genButton.prop('disabled', false).html(originalButtonHtml);
        }
    }

    function showPromptEditorPopup() { /* ... Same as v0.4.10 ... */ 
        logDebug("Showing AI Prompt Editor popup (v0.4.9)..."); // Corrected version log
        if (!coreApisAreReady || !jQuery_API || !SillyTavern_API) {
            toastr_API?.error("核心服务未就绪，无法打开提示词编辑器。");
            return;
        }

        const editorHtml = `
            <div id="${PROMPT_EDITOR_POPUP_ID}" style="display: flex; flex-direction: column; gap: 15px; padding:15px; background-color: #2e2e34; color: #f0f0f0; font-family: 'Segoe UI', sans-serif;">
                <h3 style="color: #00AEEF; margin-top:0; border-bottom: 1px solid #444; padding-bottom: 5px;">AI任务生成核心指令编辑器</h3>
                <p style="font-size: 0.9em; color: #ccc;">
                    您正在编辑AI生成任务的<b>核心指令</b>部分。脚本会自动在此指令前后添加固定的聊天记录、世界书摘要以及任务输出格式要求。
                    <br>请在此处专注于描述您希望AI生成的任务类型、数量、风格等具体要求。
                </p>
                <div style="border: 1px dashed #555; padding: 10px; background-color: #25252a; border-radius: 4px; margin-bottom: 10px; font-size: 0.8em; color: #aaa;">
                    <p style="margin-top:0;"><b>固定前缀 (不可编辑):</b> 会自动填充最新的聊天记录和世界书条目摘要。</p>
                    <pre style="white-space: pre-wrap; background-color: #202025; padding: 5px; border-radius: 3px;">最近的聊天记录:\n{chatHistory}\n\n相关的世界书条目 (摘要):\n{worldInfo}\n\n</pre>
                </div>
                <textarea id="ai-prompt-editor-textarea" style="width: 98%; min-height: 150px; padding: 10px; border-radius: 4px; background-color: #25252a; color: #f0f0f0; border: 1px solid #444; resize: vertical; font-family: monospace, 'Segoe UI'; font-size: 0.9em;">${escapeHtml(currentUserModifiedEditablePromptCore)}</textarea>
                <div style="border: 1px dashed #555; padding: 10px; background-color: #25252a; border-radius: 4px; margin-top: 10px; font-size: 0.8em; color: #aaa;">
                    <p style="margin-top:0;"><b>固定后缀 (不可编辑):</b> 包含任务输出格式 (TITLE, DESCRIPTION, REWARD) 和示例。</p>
                     <pre style="white-space: pre-wrap; background-color: #202025; padding: 5px; border-radius: 3px;">每个任务必须严格遵循以下格式...\nTITLE: [任务的中文标题]\n...\n现在请生成...任务的列表。</pre>
                </div>
                <div style="text-align: right; margin-top: 10px;">
                    <button id="restore-default-prompt-button" class="menu_button" style="margin-right: 10px; background-color: #ffc107; color: #212529;">恢复默认核心指令</button>
                    <button id="save-custom-prompt-button" class="menu_button" style="background-color: #28a745;">保存核心指令</button>
                </div>
            </div>
        `;

        const editorPopup = SillyTavern_API.callGenericPopup(editorHtml, SillyTavern_API.POPUP_TYPE.DISPLAY, "编辑AI任务核心指令", {
            wide: true,
            large: true,
            allowVerticalScrolling: true,
            buttons: [],
            callback: function(action, _popup) {
                logDebug(`Prompt editor popup closed with action: ${action}`);
                jQuery_API(this).remove();
            }
        });

        setTimeout(() => {
            const popupInstance = jQuery_API(`#${PROMPT_EDITOR_POPUP_ID}`).closest('dialog[open]');
            if (!popupInstance.length) {
                logDebug("Could not find prompt editor popup instance to bind events.");
                return;
            }

            popupInstance.find('#save-custom-prompt-button').on('click', function() {
                const newPromptCore = popupInstance.find('#ai-prompt-editor-textarea').val();
                currentUserModifiedEditablePromptCore = newPromptCore;
                toastr_API?.success("核心指令已保存！");
                logDebug("Custom AI prompt core saved:", currentUserModifiedEditablePromptCore);
                if (typeof editorPopup.close === 'function') {
                    editorPopup.close();
                } else if (popupInstance[0] && typeof popupInstance[0].close === 'function') {
                     popupInstance[0].close();
                }
            });

            popupInstance.find('#restore-default-prompt-button').on('click', function() {
                currentUserModifiedEditablePromptCore = DEFAULT_EDITABLE_PROMPT_CORE_CN;
                popupInstance.find('#ai-prompt-editor-textarea').val(DEFAULT_EDITABLE_PROMPT_CORE_CN);
                toastr_API?.info("核心指令已恢复为默认设置。");
                logDebug("AI prompt core restored to default.");
            });
        }, 200);
    }

    function createQuestPopupHtml() { /* ... Same as v0.4.10 ... */ 
        logDebug("Creating quest popup HTML (v0.4.10)..."); // Log corrected to match function state
        let html = `<div id="${QUEST_POPUP_ID}" class="quest-popup-container">`;
        html += `
            <style>
                #${QUEST_POPUP_ID} { background-color: #2e2e34; color: #f0f0f0; padding: 15px; font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; gap: 15px; max-height: 80vh; overflow-y: auto; border-radius: 8px; }
                #${QUEST_POPUP_ID} h2 { color: #00AEEF; border-bottom: 1px solid #444; padding-bottom: 5px; margin-top: 0; font-size: 1.3em; display: flex; align-items: center; gap: 8px; }
                #${QUEST_POPUP_ID} .quest-section { background-color: #383840; padding: 12px; border-radius: 6px; box-shadow: 0 1px 4px rgba(0,0,0,0.2); }
                #${QUEST_POPUP_ID} .quest-item { border-bottom: 1px solid #4a4a52; padding: 8px 0; margin-bottom: 8px; }
                #${QUEST_POPUP_ID} .quest-item:last-child { border-bottom: none; margin-bottom: 0;}
                #${QUEST_POPUP_ID} .quest-title { font-weight: bold; font-size: 1.05em; color: #90EE90; margin-bottom: 3px; }
                #${QUEST_POPUP_ID} .quest-title .fa-robot { font-size: 0.8em; color: #00AEEF; margin-left: 5px; }
                #${QUEST_POPUP_ID} .quest-description { font-size: 0.85em; color: #ccc; margin: 4px 0; line-height: 1.3; }
                #${QUEST_POPUP_ID} .quest-actions button { background-color: #007bff; color: white; border: none; padding: 7px 10px; border-radius: 4px; cursor: pointer; margin-right: 6px; transition: background-color 0.2s; font-size: 0.85em;}
                #${QUEST_POPUP_ID} .quest-actions button:hover { background-color: #0056b3; }
                #${QUEST_POPUP_ID} .quest-actions button.complete { background-color: #28a745; }
                #${QUEST_POPUP_ID} .quest-actions button.complete:hover { background-color: #1e7e34; }
                #${QUEST_POPUP_ID} .quest-actions button.abandon { background-color: #ffc107; color: #212529; }
                #${QUEST_POPUP_ID} .quest-actions button.abandon:hover { background-color: #e0a800; }
                #${QUEST_POPUP_ID} .quest-actions button:disabled { background-color: #555; cursor: not-allowed; opacity: 0.7; }
                #${QUEST_POPUP_ID} .no-tasks { color: #888; text-align: center; padding: 10px; font-style: italic; font-size:0.9em; }
                #${QUEST_POPUP_ID} .fas, #${QUEST_POPUP_ID} .fa-solid { margin-right: 5px; }
                #${QUEST_POPUP_ID} .ai-prompt-controls button { margin-left: 10px; background-color: #4CAF50; } /* Green for edit button */
            </style>
        `;

        html += `<div class="quest-section" id="ai-task-generation-section">
            <h2><i class="fas fa-robot"></i>AI 任务生成器</h2>
            <div class="quest-item">
                <p class="quest-description" style="margin-bottom: 10px;">点击下方按钮生成AI任务。您可以先编辑预设的核心指令以更好地控制生成内容。</p>
                <div class="quest-actions" style="margin-top: 8px; display: flex; justify-content: flex-start; align-items: center;">
                    <button id="trigger-ai-task-generation" class="quest-action-button" style="background-color: #6f42c1; color: white;"><i class="fas fa-magic"></i> 生成AI任务</button>
                    <button id="edit-ai-prompt-button" class="quest-action-button ai-prompt-controls" title="编辑用于AI生成任务的核心指令"><i class="fas fa-edit"></i> 编辑核心指令</button>
                </div>
            </div>
        </div>`;

        html += '<div class="quest-section"><h2><i class="fas fa-tasks"></i>当前任务</h2><div id="current-tasks-list">';
        const activeTasks = Object.entries(playerTasksStatus).filter(([_, data]) => data.status === 'active');
        if (activeTasks.length === 0) {
            html += '<p class="no-tasks">(当前没有进行中的任务)</p>';
        } else {
            activeTasks.forEach(([taskId, taskData]) => {
                html += `<div class="quest-item" data-task-id="${escapeHtml(taskId)}"><div class="quest-title">${escapeHtml(taskData.title)} ${taskData.isAIGenerated ? '<i class="fas fa-robot" title="AI生成"></i>' : ''}</div><div class="quest-description">${escapeHtml(taskData.description)}</div><div class="quest-actions" style="margin-top: 8px;"><button class="quest-action-button complete" data-action="complete" data-task-id="${escapeHtml(taskId)}"><i class="fas fa-check"></i> 完成任务</button><button class="quest-action-button abandon" data-action="abandon" data-task-id="${escapeHtml(taskId)}"><i class="fas fa-times"></i> 放弃任务</button></div></div>`;
            });
        }
        html += '</div></div>';

        html += '<div class="quest-section"><h2><i class="fas fa-plus-circle"></i>可接任务</h2><div id="available-tasks-list">';
        const availableSystemTasks = definedTasks.filter(taskDef => {
            if (playerTasksStatus[taskDef.id] && (playerTasksStatus[taskDef.id].status === 'active' || playerTasksStatus[taskDef.id].status === 'completed')) return false;
            return (taskDef.prerequisites || []).every(prereqId => playerTasksStatus[prereqId]?.status === 'completed');
        });
        if (availableSystemTasks.length === 0) {
            html += '<p class="no-tasks">(当前没有可接的新任务)</p>';
        } else {
            availableSystemTasks.forEach(taskDef => {
                html += `<div class="quest-item" data-task-id="${escapeHtml(taskDef.id)}"><div class="quest-title">${escapeHtml(taskDef.title)} ${taskDef.isAIGenerated ? '<i class="fas fa-robot" title="AI生成"></i>' : ''}</div><div class="quest-description">${escapeHtml(taskDef.description)}</div><div class="quest-actions" style="margin-top: 8px;"><button class="quest-action-button accept" data-action="accept" data-task-id="${escapeHtml(taskDef.id)}"><i class="fas fa-handshake"></i> 接受任务</button></div></div>`;
            });
        }
        html += '</div></div>';

        html += '<div class="quest-section"><h2><i class="fas fa-check-double"></i>已完成的任务</h2><div id="completed-tasks-list">';
        const completedTasks = Object.entries(playerTasksStatus).filter(([_, data]) => data.status === 'completed');
        if (completedTasks.length === 0) {
            html += '<p class="no-tasks">(尚未完成任何任务)</p>';
        } else {
            completedTasks.forEach(([taskId, taskData]) => {
                html += `<div class="quest-item" data-task-id="${escapeHtml(taskId)}"><div class="quest-title" style="color: #28a745;">${escapeHtml(taskData.title)} ${taskData.isAIGenerated ? '<i class="fas fa-robot" title="AI生成"></i>' : ''} (已完成)</div><div class="quest-description">${escapeHtml(taskData.description)}</div></div>`;
            });
        }
        html += '</div></div>';
        html += '</div>';
        return html;
    }

    function bindQuestPopupEvents(popupContent$) { /* ... Same as v0.4.10 ... */ 
        logDebug("Binding quest popup events (v0.4.10)..."); // Corrected version log
        if (!jQuery_API || !popupContent$ || popupContent$.length === 0 || typeof popupContent$.off !== 'function') {
            logDebug("bindQuestPopupEvents: jQuery_API or popupContent$ is invalid.");
            return;
        }
        popupContent$.off('click', '.quest-action-button:not(#trigger-ai-task-generation):not(#edit-ai-prompt-button)').on('click', '.quest-action-button:not(#trigger-ai-task-generation):not(#edit-ai-prompt-button)', async function(event) {
            event.stopPropagation();
            const button = jQuery_API(this);
            const action = button.data('action');
            const taskId = button.data('task-id');
            const originalButtonText = button.html();
            logDebug(`Task action button clicked: action=${action}, taskId=${taskId}`);

            if (action !== 'complete') { 
                button.prop('disabled', true).html('<i class="fas fa-spinner fa-spin"></i> 处理中...');
            }

            try {
                if (action === 'accept') {
                    await acceptTask(taskId);
                } else if (action === 'complete') {
                    await completeTask(taskId); 
                } else if (action === 'abandon') {
                    logDebug('[QuestSystem] Attempting to call abandonTask. Typeof abandonTask:', typeof abandonTask);
                    if (typeof abandonTask === 'function') {
                        await abandonTask(taskId);
                    } else {
                        console.error('[QuestSystem] abandonTask function is undefined at point of call!');
                        toastr_API?.error('内部错误：放弃任务功能异常。');
                    }
                }
            } catch (error) {
                console.error(`[QuestSystem] Error performing action ${action} for task ${taskId}:`, error);
                toastr_API?.error(`操作失败: ${error.message}`);
            } finally {
                if (action !== 'complete') {
                    const currentButtonInstance = jQuery_API(this);
                    if (currentButtonInstance.length > 0 && currentButtonInstance.closest('body').length > 0) {
                        currentButtonInstance.prop('disabled', false).html(originalButtonText);
                    } else {
                        logDebug(`Button for action '${action}' (task ${taskId}) was likely removed from DOM.`);
                    }
                }
            }
        });

        const aiGenButton = popupContent$.find('#trigger-ai-task-generation');
        if (aiGenButton.length > 0) {
            aiGenButton.off('click').on('click', async function(event) {
                event.stopPropagation();
                logDebug("AI Task Generation button clicked.");
                await generateAndAddNewAiTask();
            });
        } else {
            logDebug("AI Task Generation button not found in popup content for binding.");
        }

        const editPromptButton = popupContent$.find('#edit-ai-prompt-button');
        if (editPromptButton.length > 0) {
            editPromptButton.off('click').on('click', function(event) {
                event.stopPropagation();
                logDebug("Edit AI Prompt button clicked.");
                showPromptEditorPopup();
            });
        } else {
            logDebug("Edit AI Prompt button not found in popup content for binding.");
        }
    }
    
    // This function is now for setting up the MENU ITEM in the extensions menu
    function setupQuestMenuItem() {
        logDebug("Setting up Quest System menu item (v0.4.11)...");
        const parentDoc = (SillyTavern_API?.Chat?.document) ? SillyTavern_API.Chat.document : (window.parent || window).document;
        if (!parentDoc || !jQuery_API) {
            logDebug("Parent document or jQuery not available for setupQuestMenuItem.");
            return false;
        }

        // Target the main extensions menu popup
        const extensionsMenu = jQuery_API('#extensionsMenu', parentDoc);
        if (!extensionsMenu.length) {
            logDebug("#extensionsMenu not found. Cannot add quest menu item yet.");
            // We rely on CHAT_CHANGED or other events to re-trigger this setup when the menu might become available.
            return false;
        }

        // Check if our menu item container already exists
        if (jQuery_API(`#${QUEST_MENU_ITEM_CONTAINER_ID}`, extensionsMenu).length > 0) {
            logDebug("Quest menu item container already exists. Ensuring event handler.");
            // Re-bind click event to be safe, targeting the actual clickable item
            extensionsMenu.find(`#${QUEST_MENU_ITEM_ID}`)
                .off('click.questSystem')
                .on('click.questSystem', (event) => {
                    event.stopPropagation();
                    logDebug("Quest Log menu item clicked.");
                    showQuestLogPopup();
                });
            return true;
        }

        logDebug("Creating new Quest Log menu item for extensions menu.");

        const menuItemContainer = jQuery_API(
            `<div class="extension_container interactable" id="${QUEST_MENU_ITEM_CONTAINER_ID}" tabindex="0"></div>`
        );
        const menuItem = jQuery_API(
            `<div title="打开${BUTTON_TEXT}" class="list-group-item flex-container flexGap5 interactable" id="${QUEST_MENU_ITEM_ID}">` +
            `    <div class="fa-fw fa-solid fa-scroll extensionsMenuExtensionButton"></div>` + // Using a scroll icon
            `    <span>${BUTTON_TEXT}</span>` +
            `</div>`
        );

        menuItem.on('click.questSystem', (event) => {
            event.stopPropagation();
            logDebug("Quest Log menu item clicked.");
            // Close the extensions menu first, then show quest log
            const extensionsMenuButton = jQuery_API('#extensionsMenuButton', parentDoc);
            if (extensionsMenuButton.length && extensionsMenu.is(':visible')) {
                extensionsMenuButton.trigger('click'); // Simulate a click to close it
                setTimeout(showQuestLogPopup, 150); // Delay to allow menu to close
            } else {
                showQuestLogPopup();
            }
        });

        menuItemContainer.append(menuItem);
        extensionsMenu.append(menuItemContainer); // Append to the main extensions menu

        logDebug("Quest Log menu item added to extensions menu and event bound.");
        return true;
    }


    async function showQuestLogPopup() { /* ... Same as v0.4.10 ... */ 
        logDebug("--- showQuestLogPopup called ---");
        if (!coreApisAreReady) {
            logDebug("showQuestLogPopup: Core APIs not marked ready. Attempting to re-initialize for popup.");
            if (!attemptToLoadCoreApis()) {
                (toastr_API || window.toastr || alert)("无法打开任务日志：核心组件加载失败。");
                return;
            }
        }
        logDebug("Core APIs confirmed for popup display.");

        try {
            await loadPlayerTasks();
            const popupContentHtml = createQuestPopupHtml();
            const popupContentForDisplay = jQuery_API(popupContentHtml);

            SillyTavern_API.callGenericPopup(popupContentForDisplay, SillyTavern_API.POPUP_TYPE.DISPLAY, "任务日志", {
                wide: true, large: true, allowVerticalScrolling: true,
            }).then(() => logDebug("Quest popup closed."))
              .catch(err => {
                console.error("[QuestSystem] SillyTavern_API.callGenericPopup error:", err);
                toastr_API?.error(`显示弹窗错误: ${err.message || String(err)}`);
            });

            logDebug("SillyTavern_API.callGenericPopup initiated.");
            setTimeout(() => {
                const currentPopupInstance = jQuery_API(`dialog[open]:not([closing]) #${QUEST_POPUP_ID}`);
                if (currentPopupInstance.length > 0) {
                    bindQuestPopupEvents(currentPopupInstance);
                    logDebug("Events bound to newly opened quest popup content.");
                } else {
                    logDebug("Popup instance not found for binding after 350ms post-callGenericPopup.");
                }
            }, 350);
        } catch (error) {
            console.error("[QuestSystem] Error in showQuestLogPopup:", error);
            toastr_API?.error(`显示日志出错: ${error.message}`);
        }
    }

    // Renamed setupQuestButton to setupQuestMenuItem to reflect its new purpose
    // The mainInitialize function will now call setupQuestMenuItem

    let initAttempts = 0;
    const maxInitAttempts = 20;
    const initInterval = 1500;

    function mainInitialize() {
        initAttempts++;
        logDebug(`Main Initialization Attempt ${initAttempts}/${maxInitAttempts} (v0.4.11)`);

        if (attemptToLoadCoreApis()) {
            logDebug("Core APIs loaded successfully for mainInitialize.");
            // Call the new function to set up the menu item
            if (setupQuestMenuItem()) { // This function now handles adding the item to the extensions menu
                logDebug("Quest System initialized: APIs ready and menu item setup successful.");
                toastr_API?.success(`${BUTTON_TEXT} (v0.4.11) 已整合到扩展菜单!`, '任务扩展', { timeOut: 4000 });

                if (!questSystemEventListenersAttached) {
                    try {
                        const reSetupMenuItemOnUIChange = () => {
                            logDebug("UI change detected (CHAT_CHANGED/GROUP_UPDATED), re-validating Quest menu item.");
                            // We need to ensure the extensions menu itself exists before trying to add to it.
                            // setupQuestMenuItem already checks for #extensionsMenu.
                            setupQuestMenuItem();
                        };

                        if (TavernHelper_API && TavernHelper_API.eventOn && TavernHelper_API.eventRemoveListener && TavernHelper_API.tavern_events) {
                            TavernHelper_API.eventRemoveListener(TavernHelper_API.tavern_events.CHAT_CHANGED, reSetupMenuItemOnUIChange);
                            TavernHelper_API.eventOn(TavernHelper_API.tavern_events.CHAT_CHANGED, reSetupMenuItemOnUIChange);
                            TavernHelper_API.eventRemoveListener(TavernHelper_API.tavern_events.GROUP_UPDATED, reSetupMenuItemOnUIChange);
                            TavernHelper_API.eventOn(TavernHelper_API.tavern_events.GROUP_UPDATED, reSetupMenuItemOnUIChange);
                            // Also listen for extensions menu being shown/hidden if possible, or just rely on chat changes
                            logDebug("Bound to CHAT_CHANGED, GROUP_UPDATED via TavernHelper.eventOn for menu item refresh.");
                        } else if (SillyTavern_API && SillyTavern_API.tavern_events && typeof SillyTavern_API.tavern_events.on === 'function') {
                            SillyTavern_API.tavern_events.on('CHAT_CHANGED', reSetupMenuItemOnUIChange);
                            SillyTavern_API.tavern_events.on('GROUP_UPDATED', reSetupMenuItemOnUIChange);
                            logDebug("Bound to CHAT_CHANGED, GROUP_UPDATED via SillyTavern_API.tavern_events.on for menu item refresh.");
                        } else {
                            logDebug("Event systems not available for robust menu item re-binding.");
                        }
                        questSystemEventListenersAttached = true;
                    } catch (e) { console.error("[QuestSystem] Error setting up tavern_events for menu item refresh:", e); }
                }
                return; 
            } else {
                logDebug("Menu item setup failed even though core APIs seem loaded. Retrying mainInitialize if attempts remain.");
            }
        } else {
            logDebug("Core APIs not yet available during mainInitialize.");
        }

        if (initAttempts < maxInitAttempts) {
            setTimeout(mainInitialize, initInterval);
        } else {
            const errorMsg = "[QuestSystem] Failed to initialize completely after multiple attempts (APIs or Menu item setup).";
            console.error(errorMsg);
            (toastr_API || window.toastr || alert)(errorMsg);
        }
    }

    const getReadyState = () => {
        try { return (window.parent && window.parent.document) ? window.parent.document.readyState : document.readyState; }
        catch (e) { return document.readyState; }
    };
    const initialLoadDelay = 2500;

    const starterFunction = () => {
        if (starterFunctionCalled) {
            logDebug("starterFunction already called. Skipping duplicate execution.");
            return;
        }
        starterFunctionCalled = true;
        logDebug("Document ready/loaded. Starting QuestSystem v0.4.11 initialization process.");
        mainInitialize();
    };

    if (typeof window.QuestSystemV0411Loaded === 'undefined') { // Use a unique flag for this version
        window.QuestSystemV0411Loaded = true; 
        if (getReadyState() === 'complete') {
            setTimeout(starterFunction, initialLoadDelay);
        } else {
            const targetWin = (typeof window.parent !== "undefined" ? window.parent : window);
            targetWin.addEventListener('load', starterFunction, { once: true });
        }
    } else {
        console.log('[QuestSystem v0.4.11] Script already loaded or loading. Skipping duplicate execution.');
    }
})();
